#!/usr/bin/python3

import curses
import argparse
import os
import sys
import re
from curses import wrapper

parser = argparse.ArgumentParser(description='{}'.format(os.path.basename(__file__)))
parser.add_argument('tfile',            type=str,                   help='Trace file (output from dmce-trace)')
args = parser.parse_args()

wx_traceview = 0
wy_traceview = 0
wx_codeview = 0
wy_codeview = 40
wx_varsview = 100
wy_varsview = 40

num_srclines = 30
num_tracelines = 30

h_screen = 0
w_screen = 0

tracebuffer = []
full_tracebuffer = []
codebuffer = []
varbuffer = []
numbuffer = []
cmdbuffer = []
cmdindex = 0
cmdhistory = [[]]
cmdhistoryindex = 0
jumplist = []
jumpindex = 0
cmd_error_code = "Press 'h' for help screen!"

core_filter = []
file_filter = ""
func_filter = ""
src_filter = ""

last_search_cmd = ""
search_dir = "down"
tv_start = 0
tv_end = 0
src_start = 0
src_end = 0
index = 0
srcindex = 0
old_srcpath = ""

relaunch = False
blink = True

editor = "vim"

#log = open("/tmp/dmcetraceviewer.log", "w")
#print("dmce trace viewer log", file=log)

# look for editor configuration
user = os.environ.get("USER")
cfile = "/home/" + user + "/.dmceconfig"
if os.path.exists(cfile):
    c = open (cfile)
    config = c.readlines()
    c.close()
    for c in config:
        if "DMCE_EDITOR" in c:
            editor = c.split(":")[1].strip()
            break

user_input_mode = False

def init():
    global tracebuffer
    global full_tracebuffer
    global args

    tf = open(args.tfile)
    full_tracebuffer = tf.readlines()
    tf.close()

    i = 0
    while i < len(full_tracebuffer):
        full_tracebuffer[i] = str(i) + "@" + full_tracebuffer[i]
        i += 1

    tracebuffer = full_tracebuffer.copy()

def init_screen(stdscr):
    global wy_codeview
    global wy_varsview
    global wx_varsview
    global num_srclines
    global num_tracelines
    global w_screen
    global h_screen

    h_screen, w_screen = stdscr.getmaxyx()
    wy_codeview = wy_varsview = int(h_screen / 2)
    num_srclines = num_tracelines = int((h_screen / 2) - 3)
    wx_varsview = w_screen - int(w_screen / 4)

def draw(stdscr):
    global tracebuffer
    global varbuffer
    global codebuffer
    global index
    global tv_start
    global tv_end
    global src_start
    global src_end
    global num_srclines
    global num_tracelines
    global old_srcpath
    global blink

    # trace view
    wtout = w_screen - (w_screen - wx_varsview) - 1
    for i in range(tv_start, tv_end + 1):
        if i < len(tracebuffer):
            lout = tracebuffer[i].rstrip().split("@")
            pre = " "
            if tracebuffer[i].split("@")[0] in jumplist:
                pre = ">"
            tout = pre + '@'.join(lout[0:7]).replace("@", " ")
            tout = tout[:wtout].ljust(wtout, " ")
            if i == index:
                stdscr.addstr(wy_traceview + i - tv_start, wx_traceview, tout, curses.A_REVERSE)
            else:
                stdscr.addstr(wy_traceview + i - tv_start, wx_traceview, tout)
        else:
            stdscr.hline(wy_traceview + i - tv_start, wx_traceview, ' ', wtout)


    # code view
    srcpath = tracebuffer[index].split("@")[3]

    sf = open(srcpath)
    codebuffer = sf.readlines()
    sf.close()
    srcindex = int(tracebuffer[index].split("@")[4]) - 1

    if old_srcpath != srcpath:
        src_start = srcindex - int(num_srclines / 2)
        old_srcpath = srcpath

    if src_start > srcindex:
        src_start = srcindex - int(num_srclines / 2)

    if srcindex > (src_start + num_srclines - 1):
        src_start = srcindex - int(num_srclines / 2) + 1

    for i in range(num_srclines):
        if (src_start + i) < len(codebuffer):
            if (src_start + i) == srcindex:
                stdscr.addstr(wy_codeview + i, wx_codeview, codebuffer[src_start + i], curses.A_REVERSE)
            else:
                stdscr.addstr(wy_codeview + i, wx_codeview, codebuffer[src_start + i])
        else:
            stdscr.addstr(wy_codeview + i, wx_codeview, "                                                                           ")

    # vars view
    varstr = tracebuffer[index].split("@")[7:]
    vout = varstr[0].split(" ")
    i = 0
    for v in vout:
        stdscr.addstr(wy_varsview + i, wx_varsview, v)
        i += 1
    for j in range(5-i):
        stdscr.addstr(wy_varsview + i + j, wx_varsview, "                                           ")

    # trace info view
    entry_num = tracebuffer[index].split("@")[0]
    filename = os.path.basename(srcpath)
    core = tracebuffer[index].split("@")[1]
    timestamp = int(tracebuffer[index].split("@")[2])
    if index > 0:
        timestamp_prev = int(tracebuffer[index - 1].split("@")[2])
    else:
        timestamp_prev = 0

    diff = timestamp - timestamp_prev

    function = tracebuffer[index].split("@")[5]

    # stdscr.addstr(0, wx_varsview, "".ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(1, wx_varsview, (" Trace entry      : " + entry_num + " / " + str(len(tracebuffer))).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(2, wx_varsview, (" File             : " + filename).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(3, wx_varsview, (" Function         : " + function).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(4, wx_varsview, (" Core             : " + core).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(5, wx_varsview, (" Timestamp        : " + str(timestamp) + " (cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(6, wx_varsview, (" Timestamp prev   : " + str(timestamp_prev) + " (cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(7, wx_varsview, (" Diff             : " + str(diff) + " (cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(9, wx_varsview, (" Markers: "))
    stdscr.addstr(10, wx_varsview, (" ---------------------"))
    stdscr.addstr(11, wx_varsview, "".ljust(w_screen - wx_varsview, " "))
    pos = wx_varsview + 1
    for m in jumplist:
        if str(index) != m:
            stdscr.addstr(11, pos, str(m) + " ")
        else:
            stdscr.addstr(11, pos, str(m) + " ", curses.A_REVERSE)
        pos += len(m) + 1
    stdscr.addstr(13, wx_varsview, (" Filters"))
    stdscr.addstr(14, wx_varsview, (" ---------------------"))
    stdscr.addstr(15, wx_varsview, (" Cores: " + ", ".join(core_filter)).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(16, wx_varsview, (" Files: " + file_filter).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(17, wx_varsview, (" Funcs: " + func_filter).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(18, wx_varsview, (" Srcs : " + src_filter).ljust(w_screen - wx_varsview, " "))

    # info / error codes
    if blink:
        stdscr.addstr(wy_codeview + num_srclines + 1, wx_varsview, cmd_error_code.ljust(w_screen - wx_varsview, " "), curses.A_BLINK)
    else:
        stdscr.addstr(wy_codeview + num_srclines + 1, wx_varsview, cmd_error_code.ljust(w_screen - wx_varsview, " "))

    # bars
    stdscr.hline(wy_codeview - 2, wx_codeview, '_', w_screen)
    stdscr.hline(wy_codeview + num_srclines, wx_codeview, '_', w_screen)
    stdscr.vline(0, wx_varsview - 1, '|', h_screen)

    # cmd view
    stdscr.hline(wy_codeview + num_srclines + 1, wx_codeview, ' ', w_screen - wx_varsview - 1)

    if user_input_mode:
        cmdstr1 = "".join(cmdbuffer[:cmdindex])
        cmdstr2 = "".join(cmdbuffer[cmdindex:])
        stdscr.addstr(wy_codeview + num_srclines + 1, cmdindex + 1, cmdstr2)
        stdscr.addstr(wy_codeview + num_srclines + 1, 0, ":" + cmdstr1)

def cleanup_exit():
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()

def goto_index(istr):
    global index
    global tracebuffer

    # interval halving later if needed!
    i = 0
    while i < len(tracebuffer):
        if (istr == tracebuffer[i].split("@")[0]):
            index = i
            return
        i += 1
    index = 0

def clear_core_filter():
    global cmd_error_code
    global core_filter

    core_filter = []
    apply_all_filters()
    cmd_error_code = "Core filter reset"

def clear_file_filter():
    global cmd_error_code
    global file_filter

    file_filter = ""
    apply_all_filters()
    cmd_error_code = "File filter reset"

def clear_func_filter():
    global cmd_error_code
    global func_filter

    func_filter = ""
    apply_all_filters()
    cmd_error_code = "Func filter reset"

def clear_src_filter():
    global cmd_error_code
    global src_filter

    src_filter = ""
    apply_all_filters()
    cmd_error_code = "src filter reset"


def apply_all_filters():
    global core_filter
    global tracebuffer
    global full_tracebuffer
    global cmd_error_code

    tracebuffer_tmp = full_tracebuffer.copy()
    cur_index = tracebuffer[index].split("@")[0]

    # core filter
    if len(core_filter) > 0:
        f = "|".join(core_filter)
        sr = '^\d*@(' + f + ')@.*'
        re_core = re.compile(sr)
        tracebuffer_tmp = list(filter(lambda tline: re_core.match(tline), full_tracebuffer))


    # file filter
    if file_filter != "":
        sr = '^.*@.*@.*@(.*' + file_filter + '.*)@.*@.*@.*'
        re_core = re.compile(sr)
        tracebuffer_tmp = list(filter(lambda tline: re_core.match(tline), tracebuffer_tmp))


    # function filter
    if func_filter != "":
        sr = '^.*@.*@.*@.*@.*@(.*' + func_filter + '.*)@.*'
        re_core = re.compile(sr)
        tracebuffer_tmp = list(filter(lambda tline: re_core.match(tline), tracebuffer_tmp))


    # src filter
    if src_filter != "":
        sr = '^.*@.*@.*@.*@.*@.*@(.*' + src_filter + '.*)'
        re_core = re.compile(sr)
        tracebuffer_tmp = list(filter(lambda tline: re_core.match(tline), tracebuffer_tmp))


    if len(tracebuffer_tmp) == 0:
        cmd_error_code = "No trace entries matching requested filter"
        return False

    tracebuffer = tracebuffer_tmp.copy()
    goto_index(cur_index)
    return True

def filter_cores(cores):
    global cmd_error_code
    global core_filter

    if cores == "clear":
        clear_core_filter()
        return
    else:
        core_filter_copy = core_filter

        core_filter = []
        for c in cores.split(","):
            c = c.strip()
            if c.isdigit():
                core_filter.append(c)
            else:
                core_filter = core_filter_copy
                cmd_error_code = "'filter cores' needs a comma separated list of cores or 'clear'"
                return

        if not apply_all_filters():
            core_filter = core_filter_copy

def filter_files(files):
    global cmd_error_code
    global file_filter

    if files == "clear":
        clear_file_filter()
        return
    else:
        file_filter_copy = file_filter

        file_filter = files

        if not apply_all_filters():
            file_filter = file_filter_copy

def filter_funcs(funcs):
    global cmd_error_code
    global func_filter

    if funcs == "clear":
        clear_func_filter()
        return
    else:
        func_filter_copy = func_filter

        func_filter = funcs

        if not apply_all_filters():
            func_filter = func_filter_copy

def filter_srcs(srcs):
    global cmd_error_code
    global src_filter

    if srcs == "clear":
        clear_src_filter()
        return
    else:
        src_filter_copy = src_filter

        src_filter = srcs

        if not apply_all_filters():
            src_filter = src_filter_copy


def clear_all_filters():
    clear_core_filter()
    clear_file_filter()
    clear_func_filter()
    clear_src_filter()
    return

def cmd_filter(cmds):
    global cmd_error_code
    if len(cmds) >= 2:
        if cmds[1] == "core":
            if len(cmds) >= 3:
                filter_cores(cmds[2])
                return
        elif cmds[1] == "file":
            if len(cmds) >= 3:
                filter_files(cmds[2])
                return
        elif cmds[1] == "func":
            if len(cmds) >= 3:
                filter_funcs(cmds[2])
                return
        elif cmds[1] == "src":
            if len(cmds) >= 3:
                filter_srcs(cmds[2])
                return
        elif cmds[1] == "clear":
            clear_all_filters()
            return
    cmd_error_code = "Bad filter: '" + " ".join(cmds[1:]) + "'"
    return

def cmd_search(sstr):
    global cmd_error_code
    global last_search_cmd
    global tracebuffer
    global index
    global search_dir

    if len(sstr) > 1:
        if sstr[:2] == "/'":
            r = re.compile(sstr[2:])
            if search_dir == "down":
                i = index + 1
                while i < len(tracebuffer):
                    if r.search(tracebuffer[i]):
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i += 1
            else:
                i = index - 1
                while i > 0:
                    if r.search(tracebuffer[i]):
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i -= 1
        else:
            if search_dir == "down":
                i = index + 1
                while i < len(tracebuffer):
                    if sstr[1:] in tracebuffer[i]:
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i += 1
            else:
                i = index - 1
                while i > 0:
                    if sstr[1:] in tracebuffer[i]:
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i -= 1

        cmd_error_code = "Not found: " + sstr[1:]
        return
    else:
        cmd_error_code = "Empty search string!"
        return

def execute_command(cmdstr):
    global cmd_error_code

    if len(cmdstr) == 0:
        return

    if cmdstr[0] == "/":
        cmd_search(cmdstr)
        return

    cmds  = cmdstr.split(" ")

    if cmds[0] == "filter":
        cmd_filter(cmds)
        return

    cmd_error_code = "Command not recognized: '" + cmdstr + "'"
    return

def show_help(stdscr):
    stdscr.clear()
    stdscr.addstr(0, 0,  "  Keys")
    stdscr.addstr(1, 0,  "  ---------------------------------------------------------")
    stdscr.addstr(2, 0,  "  q             - quit")
    stdscr.addstr(3, 0,  "  arrow up      - move upwards")
    stdscr.addstr(4, 0,  "  arrow down    - move downwards")
    stdscr.addstr(5, 0,  "  page up       - move one page up")
    stdscr.addstr(6, 0,  "  page up       - move one page up")
    stdscr.addstr(7, 0,  "  :             - Enter command mode")
    stdscr.addstr(8, 0,  "  /             - Enter command mode and search")
    stdscr.addstr(9, 0,  "  n             - search downwards")
    stdscr.addstr(10, 0, "  N             - search upwards")
    stdscr.addstr(11, 0, "  g             - move to the top")
    stdscr.addstr(12, 0, "  G             - move to the bottom")
    stdscr.addstr(13, 0, "  [digits]g     - move to trace entry with index [digits]")
    stdscr.addstr(14, 0, "  s             - add trace entry to jump list (markers)")
    stdscr.addstr(15, 0, "  j             - jump to next marker")
    stdscr.addstr(16, 0, "  J             - jump to previous marker")
    stdscr.addstr(17, 0, "  b             - toggle blink / no blink info pane")
    stdscr.addstr(18, 0, "  ENTER         - open current source file in editor")
    stdscr.addstr(19, 0, "  ESCAPE        - exit command mode")
    stdscr.addstr(21, 0, "  Commands")
    stdscr.addstr(22, 0, "  ---------------------------------------------------------")
    stdscr.addstr(23, 0, "  filter core A,B,C     - filter on core number")
    stdscr.addstr(24, 0, "  filter core clear     - clear core filter")
    stdscr.addstr(25, 0, "  filter file <regexp>  - filter on path/filename")
    stdscr.addstr(26, 0, "  filter file clear     - clear file filter")
    stdscr.addstr(27, 0, "  filter func <regexp>  - filter on function name")
    stdscr.addstr(28, 0, "  filter func clear     - clear func filter")
    stdscr.addstr(29, 0, "  filter src <regexp>   - filter on src line")
    stdscr.addstr(30, 0, "  filter src clear      - clear src filter")
    stdscr.addstr(31, 0, "  filter clear          - clear all filters")
    stdscr.addstr(33, 0, "  Hints")
    stdscr.addstr(34, 0, "  ---------------------------------------------------------------------")
    stdscr.addstr(35, 0, "  - In command mode, any string prepended by '/' will be searched for)")
    stdscr.addstr(36, 0, "  - Python regular expressions can be used for searches using a ' sign")
    stdscr.addstr(37, 0, "    Example: :/'.*foo.*bar")

    c = stdscr.getch()

def launch_editor(stdscr):
    global tracebuffer
    global index
    global relaunch
    global editor

    filename = tracebuffer[index].split("@")[3]
    linenbr = tracebuffer[index].split("@")[4]
    if "vi" in editor or "emacs" in editor or "nano" in editor:
        os.system(editor + " " + linenbr + " " + filename)
    else:
        os.system(editor + " " + filename)
    relaunch = True

def jump(direction):
    global jumplist
    global jumpindex
    global tracebuffer
    global cmd_error_code
    global index

    if len(jumplist) > 0:
        if direction == "forward":
            jumpindex += 1
            if jumpindex >= len(jumplist):
                jumpindex = 0
        else:
            jumpindex -= 1
            if jumpindex < 0:
                jumpindex = len(jumplist) - 1

        # Replace linear search with interval halving later if needed...

        i = 0
        ejump = jumplist[jumpindex]
        found = False
        while i < len(tracebuffer):
            if tracebuffer[i].split("@")[0] == ejump:
                index = i
                found  = True
                break
            i += 1
        if not found:
            cmd_error_code = "Trace entry '" + ejump + "' not available in this filter view"
        else:
            cmd_error_code = "Jumped to marker " + str(jumpindex)
    else:
        cmd_error_code = "No markers set!"

def set_marker():
    global jumpindex
    global jumplist

    curindex = tracebuffer[index].split("@")[0]
    # unset?
    if curindex in jumplist:
        jumplist.remove(curindex)
        return

    jumpindex = len(jumplist)
    jumplist.append(curindex)

def clear_jumplist():
    global jumpindex
    global jumplist

    jumpindex = 0
    jumplist = []

def main(stdscr, relaunched = False):
    global cmd_error_code
    global tracebuffer
    global numbuffer
    global cmdbuffer
    global cmdindex
    global cmdhistory
    global cmdhistoryindex
    global index
    global tv_start
    global tv_end
    global user_input_mode
    global search_dir
    global relaunch
    global w_screen
    global h_screen
    global blink

    curses.curs_set(0)

    relaunch = False

    if not relaunched:
        init()
        init_screen(stdscr)
        index = len(tracebuffer) - 1

    c = ord('z')

    while 1:
        # resize stuff
        if curses.is_term_resized(h_screen, w_screen):
            init_screen(stdscr)
            stdscr.clear()
#            curses.resizeterm(y, x)

        # cmd being written
        if user_input_mode:
            curses.curs_set(1)
            search_dir = "down"
            if c == 27:
                cmdbuffer = []
                cmdindex = 0
                user_input_mode = False
            elif c == curses.KEY_ENTER or c == 10 or c == 13:
                if len(cmdbuffer) > 0:
                    cmdhistory.insert(1,cmdbuffer.copy())
                    cmdhistoryindex = 0
                    execute_command("".join(cmdbuffer))
                    cmdbuffer = []
                    cmdindex = 0
                user_input_mode = False
            elif len(cmdbuffer) > 0 and c == curses.KEY_BACKSPACE:
                cmdindex -= 1
                if cmdindex < 0:
                    cmdindex = 0
                    cmdbuffer = []
                else:
                    cmdbuffer.pop(cmdindex)
            elif c >= 32 and c <= 126:
                cmdbuffer.insert(cmdindex, chr(c))
                cmdindex += 1
            elif c == curses.KEY_RIGHT:
                cmdindex += 1
                if cmdindex > len(cmdbuffer):
                    cmdindex = len(cmdbuffer)
            elif c == curses.KEY_LEFT:
                cmdindex -= 1
                if cmdindex < 0:
                    cmdindex = 0
            elif c == curses.KEY_DOWN:
                cmdhistoryindex -= 1
                if cmdhistoryindex < 0:
                    cmdhistoryindex = len(cmdhistory) - 1
                cmdbuffer = cmdhistory[cmdhistoryindex].copy()
            elif c == curses.KEY_UP:
                cmdhistoryindex += 1
                if cmdhistoryindex > len(cmdhistory) - 1:
                    cmdhistoryindex = 0
                cmdbuffer = cmdhistory[cmdhistoryindex].copy()
        else:
            curses.curs_set(0)
            if c == ord('h'):
                show_help(stdscr)
            elif c == ord(':'):
                user_input_mode = True
            elif c == ord('/'):
                user_input_mode = True
                cmdbuffer = ['/']
                cmdindex = 1
            elif c == ord('g'):
                if len(numbuffer) > 0:
                    ijump = 0
                    dec = 1
                    for n in reversed(numbuffer):
                        ijump += dec * n
                        dec = dec * 10
                    index = ijump
                    if index < 0:
                        index = 0
                    if index > (len(tracebuffer) - 1):
                        index = len(tracebuffer) - 1
                    numbuffer = []
                else:
                    index = 0

                old_srcpath = ""
            elif c == ord('G'):
                index = len(tracebuffer) - 1
            elif c == ord('n'):
                search_dir = "down"
                execute_command(last_search_cmd)
                cmdbuffer = []
                user_input_mode = False
            elif c == ord('N'):
                search_dir = "up"
                execute_command(last_search_cmd)
                cmdbuffer = []
                user_input_mode = False
            elif c == curses.KEY_UP:
                if index > 0:
                    index -= 1
            elif c == curses.KEY_DOWN:
                if index < len(tracebuffer) - 1:
                    index += 1
            elif c == curses.KEY_PPAGE:
                index -= num_tracelines
                if index < 0:
                    index = 0
            elif c == curses.KEY_NPAGE:
                index += num_tracelines
                if index > (len(tracebuffer) - 1):
                    index = len(tracebuffer) - 1
            elif c == ord('s'):
                set_marker()
            elif c == ord('c'):
                clear_jumplist()
            elif c == ord('j'):
                jump("forward")
            elif c == ord('J'):
                jump("back")
            elif c == ord('b'):
                if blink:
                    blink = False
                else:
                    blink = True
            elif c >= ord('0') and c <= ord('9'):
                numbuffer.append(int(c - ord('0')))
            elif c == curses.KEY_ENTER or c == 10 or c == 13:
                launch_editor(stdscr)
            if c == ord('q') or relaunch:
                break
        if index < tv_start:
            tv_start = index
        if index >= tv_end:
            tv_start = index - num_tracelines

        tv_end = tv_start + num_tracelines

        draw(stdscr)
#        stdscr.addstr(50, 0, "INDEX: " + str(cmdindex) + "   LIST: " + str(cmdbuffer))
        c = stdscr.getch()

os.environ.setdefault('ESCDELAY', '25')
wrapper(main)
while relaunch:
    os.environ.setdefault('ESCDELAY', '25')
    wrapper(main, relaunched = True)


# EOF
