#!/usr/bin/python3

import curses
import argparse
import os
import sys
import re
from curses import wrapper

parser = argparse.ArgumentParser(description='{}'.format(os.path.basename(__file__)))
parser.add_argument('tfile',            type=str,                   help='Trace file (output from dmce-trace)')
args = parser.parse_args()

wx_traceview = 0
wy_traceview = 0
wx_codeview = 0
wy_codeview = 40
wx_varsview = 100
wy_varsview = 40

num_srclines = 30
num_tracelines = 30

h_screen = 0
w_screen = 0

tracebuffer = []
full_tracebuffer = []
trace_info = []
codebuffer = []
varbuffer = []
numbuffer = []
cmdbuffer = []
cmdindex = 0
cmdhistory = [[]]
cmdhistoryindex = 0
jumplist = []
jumpindex = 0
cmd_error_code = "Press 'h' for help screen!"

core_filter = []
file_filter = ""
func_filter = ""
src_filter = ""

last_search_cmd = ""
search_dir = "down"
tv_start = 0
tv_end = 0
src_start = 0
src_end = 0
index = 0
srcindex = 0
old_srcpath = ""

relaunch = False
blink = True
show_probes = False
ts_min = sys.maxsize

editor = "vim"

log = open("/tmp/dmcetraceviewer.log", "w")
#print("dmce trace viewer log", file=log)

# look for editor configuration
home = os.environ.get("HOME")
cfile = home + "/.dmceconfig"
if os.path.exists(cfile):
    c = open (cfile)
    config = c.readlines()
    c.close()
    for c in config:
        if "DMCE_EDITOR" in c:
            editor = c.split(":")[1].strip()
            break

user_input_mode = False

def init():
    global tracebuffer
    global full_tracebuffer
    global args
    global ts_min
    global trace_info

    tf = open(args.tfile)
    full_tracebuffer = tf.readlines()
    tf.close()

    info_end = 0
    for line in full_tracebuffer:
        if not "- - - - -" in line:
            trace_info.append(line.rstrip())
            info_end +=1
        else:
            info_end +=1
            break

    full_tracebuffer = full_tracebuffer[info_end:]

    i = 0
    while i < len(full_tracebuffer):
        # find smallest ts to normalize the rest
        ts = int(full_tracebuffer[i].split("@")[1])
        if ts < ts_min:
            ts_min = ts
        # prepend with trace entry nbr
        full_tracebuffer[i] = str(i) + "@" + full_tracebuffer[i]
        i += 1

    tracebuffer = full_tracebuffer.copy()

def init_screen(stdscr):
    global wy_codeview
    global wy_varsview
    global wx_varsview
    global num_srclines
    global num_tracelines
    global w_screen
    global h_screen
    global screen_large_enough

    h_screen, w_screen = stdscr.getmaxyx()
    screen_large_enough = True
    if (h_screen < 40) or (w_screen < 120):
        screen_large_enough = False
    wy_codeview = wy_varsview = int(h_screen / 2)
    num_srclines = num_tracelines = int((h_screen / 2) - 3)
    wx_varsview = w_screen - int(w_screen / 4)

    curses.use_default_colors()


def check_and_clean_probes(line):

    if show_probes:
        return line

    # Convert from DMCE_PROBE to DMCE_PROBE0
    line = line.replace("DMCE_PROBE(", "DMCE_PROBE0(")

    cline = line

    # num vars
    m = re.match(r'.*DMCE_PROBE(\d*)', line)
    if m:
        numvars = m.group(1)
        pos = line.index("DMCE_PROBE")
        count = 1
        while pos < len(line) and count > 0:
            if line[pos] == "(":
                count += 1
            elif line[pos] == ")":
                count -= 1
            pos += 1

        if pos < len(line) and line[pos - 1] == ")":
            cline = line[:pos - 1] + line[pos:]

        if numvars == "0":
            cline = re.sub(r'\(DMCE_PROBE0\(\d*\)\, ', "", cline)
        else:
            cline = re.sub(r'\(DMCE_PROBE(\d*)\(\d*\,(\S*\,){' + numvars + '} ', "", cline)

        # Special case for calltrace lines
        cline = re.sub(r'{DMCE_PROBE\d\(.*\/\* Function entry.*\*\/', "{", cline)
        cline = re.sub(r'DMCE_PROBE\d\(.*\/\* Function exit.*\*\/ }', "}", cline)

    return cline

def draw(stdscr):
    global tracebuffer
    global varbuffer
    global codebuffer
    global index
    global tv_start
    global tv_end
    global src_start
    global src_end
    global num_srclines
    global num_tracelines
    global old_srcpath
    global blink
    global trace_info

    if not screen_large_enough:
        stdscr.addstr(0,0, "Terminal too small! Please increase window size.", curses.A_REVERSE)
        return

    # trace view
    wtout = w_screen - (w_screen - wx_varsview) - 1
    for i in range(tv_start, tv_end + 1):
        if i < len(tracebuffer) and i >= 0:
            lout = check_and_clean_probes(tracebuffer[i].rstrip()).split("@")
            pre = " "
            if tracebuffer[i].split("@")[0] in jumplist:
                pre = ">"
            tout = pre + '@'.join(lout[0:7]).replace("@", " ")
            tout = tout[:wtout].ljust(wtout, " ")
            if i == index:
                stdscr.addstr(wy_traceview + i - tv_start, wx_traceview, tout, curses.A_REVERSE)
            else:
                stdscr.addstr(wy_traceview + i - tv_start, wx_traceview, tout)
        else:
            stdscr.hline(wy_traceview + i - tv_start, wx_traceview, ' ', wtout)


    # code view
    srcpath = tracebuffer[index].split("@")[3]

    sf = open(srcpath)
    codebuffer = sf.readlines()
    sf.close()
    srcindex = int(tracebuffer[index].split("@")[4]) - 1

    if old_srcpath != srcpath:
        src_start = srcindex - int(num_srclines / 2)
        old_srcpath = srcpath

    if src_start > srcindex:
        src_start = srcindex - int(num_srclines / 2)

    if srcindex > (src_start + num_srclines - 1):
        src_start = srcindex - int(num_srclines / 2) + 1

    wcout = w_screen - (w_screen - wx_varsview) - 1
    for i in range(num_srclines):
        if (src_start + i) < len(codebuffer) and (src_start + i) >= 0:
            if (src_start + i) == srcindex:
                stdscr.addstr(wy_codeview + i, wx_codeview, check_and_clean_probes(codebuffer[src_start + i])[:wcout].ljust(wcout, " "), curses.A_REVERSE)
            else:
                stdscr.addstr(wy_codeview + i, wx_codeview, check_and_clean_probes(codebuffer[src_start + i])[:wcout].ljust(wcout, " "))
        else:
            stdscr.addstr(wy_codeview + i, wx_codeview, "                                                                           ")

    # vars view
    varstr = tracebuffer[index].split("@")[7:]
    vout = varstr[0].split(" ")
    i = 0
    for v in sorted(vout):
        if v.strip() != "":
            try:
                stdscr.addstr(wy_varsview + i, wx_varsview, v.strip().ljust(w_screen - wx_varsview, " "))
            except curses.error:
                pass
        i += 1
    for j in range(5-i):
        stdscr.addstr(wy_varsview + i, wx_varsview, "".ljust(w_screen - wx_varsview, " "))

    # trace info view
    entry_num = tracebuffer[index].split("@")[0]
    filename = os.path.basename(srcpath)
    core = tracebuffer[index].split("@")[1]
    timestamp = int(tracebuffer[index].split("@")[2])
    if index > 0:
        timestamp_prev = int(tracebuffer[index - 1].split("@")[2])
    else:
        timestamp_prev = 0

    diff = timestamp - timestamp_prev

    function = tracebuffer[index].split("@")[5]

    compressed = ""
    if len(core_filter) > 0:
        seq = False
        for i in range(len(core_filter) - 1):
            if not seq:
                if int(core_filter[i]) == int(core_filter[i + 1]) - 1:
                    seq = True
                    compressed = compressed + core_filter[i] + "-"
                else:
                    compressed = compressed + core_filter[i] + ","
            else:
                if int(core_filter[i]) != int(core_filter[i + 1]) - 1:
                    seq = False
                    compressed = compressed + core_filter[i] + ","

        compressed = compressed + core_filter[len(core_filter) - 1]

    # stdscr.addstr(0, wx_varsview, "".ljust(w_screen - wx_varsview, " "))
    ti_offset = len(trace_info)
    for i in range(ti_offset):
        stdscr.addstr(i, wx_varsview, " " + trace_info[i])

    stdscr.addstr(ti_offset + 1, wx_varsview, (" Trace entry      : " + entry_num + " / " + str(len(tracebuffer))).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 2, wx_varsview, (" File             : " + filename + " +" + str(srcindex + 1)).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 3, wx_varsview, (" Function         : " + function).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 4, wx_varsview, (" Core             : " + core).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 5, wx_varsview, (" Timestamp        : " + str(timestamp - ts_min) + " (rel. cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 6, wx_varsview, (" Timestamp prev   : " + str(timestamp_prev - ts_min) + " (rel. cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 7, wx_varsview, (" Diff             : " + str(diff) + " (cc)").ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 9, wx_varsview, (" Markers: "))
    stdscr.addstr(ti_offset + 10, wx_varsview, (" ---------------------"))
    stdscr.addstr(ti_offset + 11, wx_varsview, "".ljust(w_screen - wx_varsview, " "))
    pos = wx_varsview + 1
    for m in jumplist:
        if str(entry_num) != m:
            stdscr.addstr(ti_offset + ti_offset + 11, pos, str(m) + " ")
        else:
            stdscr.addstr(ti_offset + 11, pos, str(m) + " ", curses.A_REVERSE)
        pos += len(m) + 1
    stdscr.addstr(ti_offset + 13, wx_varsview, (" Filters"))
    stdscr.addstr(ti_offset + 14, wx_varsview, (" ---------------------"))
    stdscr.addstr(ti_offset + 15, wx_varsview, (" Cores: " + compressed).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 16, wx_varsview, (" Files: " + file_filter).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 17, wx_varsview, (" Funcs: " + func_filter).ljust(w_screen - wx_varsview, " "))
    stdscr.addstr(ti_offset + 18, wx_varsview, (" Srcs : " + src_filter).ljust(w_screen - wx_varsview, " "))

    # info / error codes
    if blink:
        stdscr.addstr(wy_codeview + num_srclines + 1, wx_varsview, cmd_error_code.ljust(w_screen - wx_varsview, " "), curses.A_BLINK)
    else:
        stdscr.addstr(wy_codeview + num_srclines + 1, wx_varsview, cmd_error_code.ljust(w_screen - wx_varsview, " "))

    # bars
    stdscr.hline(wy_codeview - 2, wx_codeview, '_', w_screen)
    stdscr.hline(wy_codeview + num_srclines, wx_codeview, '_', w_screen)
    stdscr.vline(0, wx_varsview - 1, '|', h_screen)

    # cmd view
    stdscr.hline(wy_codeview + num_srclines + 1, wx_codeview, ' ', w_screen - wx_varsview - 1)

    if user_input_mode:
        cmdstr1 = "".join(cmdbuffer[:cmdindex])
        cmdstr2 = "".join(cmdbuffer[cmdindex:])
        stdscr.addstr(wy_codeview + num_srclines + 1, cmdindex + 1, cmdstr2)
        stdscr.addstr(wy_codeview + num_srclines + 1, 0, ":" + cmdstr1)

def cleanup_exit():
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()

def goto_index(istr):
    global index
    global tracebuffer

    # interval halving later if needed!
    i = 0
    while i < len(tracebuffer):
        if (istr == tracebuffer[i].split("@")[0]):
            index = i
            return
        i += 1
    index = 0

def clear_core_filter():
    global cmd_error_code
    global core_filter

    core_filter = []
    apply_all_filters()
    cmd_error_code = "Core filter reset"

def clear_file_filter():
    global cmd_error_code
    global file_filter

    file_filter = ""
    apply_all_filters()
    cmd_error_code = "File filter reset"

def clear_func_filter():
    global cmd_error_code
    global func_filter

    func_filter = ""
    apply_all_filters()
    cmd_error_code = "Func filter reset"

def clear_src_filter():
    global cmd_error_code
    global src_filter

    src_filter = ""
    apply_all_filters()
    cmd_error_code = "src filter reset"


def re_compile_and_check(s):
    global cmd_error_code
    cmd_error_code = ""
    try:
        r = re.compile(s)
    except:
        cmd_error_code = "Invalid regexp"
        return None
    return r

def apply_all_filters():
    global core_filter
    global tracebuffer
    global full_tracebuffer
    global cmd_error_code

    tracebuffer_tmp = full_tracebuffer.copy()
    cur_index = tracebuffer[index].split("@")[0]

    # core filter
    if len(core_filter) > 0:
        f = "|".join(core_filter)
        sr = '^\d*@(' + f + ')@.*'
        re_core = re_compile_and_check(sr)
        if re_core is not None:
            tracebuffer_tmp = list(filter(lambda tline: re_core.match(tline), full_tracebuffer))
        else:
            return

    # file filter
    if file_filter != "":
        sr = '^.*@.*@.*@.*' + file_filter + '.*@.*@.*@.*'
        re_file = re_compile_and_check(sr)
        if re_file is not None:
            tracebuffer_tmp = list(filter(lambda tline: re_file.match(tline), tracebuffer_tmp))
        else:
            return

    # function filter
    if func_filter != "":
        sr = '^.*@.*@.*@.*@.*' + func_filter + '.*@.*@.*'
        re_func = re_compile_and_check(sr)
        if re_func is not None:
            tracebuffer_tmp = list(filter(lambda tline: re_func.match(tline), tracebuffer_tmp))
        else:
            return

    # src filter
    if src_filter != "":
        sr = '^.*@.*@.*@.*@.*@.*@.*' + src_filter + '.*'
        re_src = re_compile_and_check(sr)
        if re_src is not None:
            tracebuffer_tmp = list(filter(lambda tline: re_src.match(tline), tracebuffer_tmp))
        else:
            return

    if len(tracebuffer_tmp) == 0:
        cmd_error_code = "No trace entries matching requested filter"
        return False

    tracebuffer = tracebuffer_tmp.copy()
    goto_index(cur_index)
    return True

def filter_cores(cores):
    global cmd_error_code
    global core_filter

    if cores == "clear":
        clear_core_filter()
        return
    else:
        core_filter_copy = core_filter

        # replace any intervals with comma-separated list
        for r in re.finditer("(\d*)-(\d*)", cores):
            expand = ""
            for i in range(int(r.group(1)), int(r.group(2)) + 1):
                expand = expand  + str(i) + ","
            expand = re.sub(",$","",expand)
            cores = cores.replace(r.group(1) + "-" + r.group(2), expand)

        core_filter = []
        for c in cores.split(","):
            c = c.strip()
            if c.isdigit():
                core_filter.append(c)
            else:
                core_filter = core_filter_copy
                cmd_error_code = "'filter cores' needs a comma separated list of cores or 'clear'"
                return

        if not apply_all_filters():
            core_filter = core_filter_copy

def filter_files(files):
    global cmd_error_code
    global file_filter

    if files == "clear":
        clear_file_filter()
        return
    else:
        file_filter_copy = file_filter

        file_filter = files

        if not apply_all_filters():
            file_filter = file_filter_copy

def filter_funcs(funcs):
    global cmd_error_code
    global func_filter

    if funcs == "clear":
        clear_func_filter()
        return
    else:
        func_filter_copy = func_filter

        func_filter = funcs

        if not apply_all_filters():
            func_filter = func_filter_copy

def filter_srcs(srcs):
    global cmd_error_code
    global src_filter

    if srcs == "clear":
        clear_src_filter()
        return
    else:
        src_filter_copy = src_filter

        src_filter = srcs

        if not apply_all_filters():
            src_filter = src_filter_copy


def clear_all_filters():
    clear_core_filter()
    clear_file_filter()
    clear_func_filter()
    clear_src_filter()
    return

def cmd_filter(cmds):
    global cmd_error_code
    if len(cmds) >= 2:
        if cmds[1] == "core":
            if len(cmds) >= 3:
                filter_cores(cmds[2])
                return
        elif cmds[1] == "file":
            if len(cmds) >= 3:
                filter_files(cmds[2].replace("@", "@\+"))
                return
        elif cmds[1] == "func":
            if len(cmds) >= 3:
                filter_funcs(cmds[2])
                return
        elif cmds[1] == "src":
            if len(cmds) >= 3:
                filter_srcs(cmds[2])
                return
        elif cmds[1] == "clear":
            clear_all_filters()
            return
    cmd_error_code = "Bad filter: '" + " ".join(cmds[1:]) + "'"
    return


def cmd_search(sstr):
    global cmd_error_code
    global last_search_cmd
    global tracebuffer
    global index
    global search_dir

    if len(sstr) > 1:
        if sstr[:2] == "/'":
            r = re_compile_and_check(sstr[2:])
            if r is not None:
                if search_dir == "down":
                    i = index + 1
                    while i < len(tracebuffer):
                        if r.search(tracebuffer[i]):
                            nbr_te = tracebuffer[i].split("@")[0]
                            cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                            index = i
                            last_search_cmd = sstr
                            return
                        i += 1
                else:
                    i = index - 1
                    while i > 0:
                        if r.search(tracebuffer[i]):
                            nbr_te = tracebuffer[i].split("@")[0]
                            cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                            index = i
                            last_search_cmd = sstr
                            return
                        i -= 1
            else:
                return
        else:
            if search_dir == "down":
                i = index + 1
                while i < len(tracebuffer):
                    if sstr[1:] in tracebuffer[i]:
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i += 1
            else:
                i = index - 1
                while i > 0:
                    if sstr[1:] in tracebuffer[i]:
                        nbr_te = tracebuffer[i].split("@")[0]
                        cmd_error_code = "Found '" + sstr[1:] + "' at trace entry: " + nbr_te
                        index = i
                        last_search_cmd = sstr
                        return
                    i -= 1

        cmd_error_code = "Not found: " + sstr[1:]
        return
    else:
        cmd_error_code = "Empty search string!"
        return

def execute_command(cmdstr, stdscr):
    global cmd_error_code

    if len(cmdstr) == 0:
        return

    if cmdstr[0] == "/":
        cmd_search(cmdstr)
        return

    cmds  = cmdstr.split(" ")

    if cmds[0] == "filter":
        cmd_filter(cmds)
        return
    elif cmds[0] == "help":
        show_help(stdscr)
        return
    elif cmds[0] == "q" or cmds[0] == "qa":
        sys.exit(0)

    cmd_error_code = "Command not recognized: '" + cmdstr + "'"
    return

def show_help(stdscr):
    stdscr.clear()
    stdscr.addstr(0, 0,  "  Keys")
    stdscr.addstr(1, 0,  "  ---------------------------------------------------------")
    stdscr.addstr(2, 0,  "  q             - quit")
    stdscr.addstr(3, 0,  "  arrow up      - move upwards")
    stdscr.addstr(4, 0,  "  arrow down    - move downwards")
    stdscr.addstr(5, 0,  "  page up       - move one page up")
    stdscr.addstr(6, 0,  "  page up       - move one page up")
    stdscr.addstr(7, 0,  "  :             - Enter command mode")
    stdscr.addstr(8, 0,  "  /             - Enter command mode and search")
    stdscr.addstr(9, 0,  "  n             - search downwards")
    stdscr.addstr(10, 0, "  N             - search upwards")
    stdscr.addstr(11, 0, "  g             - move to the top")
    stdscr.addstr(12, 0, "  G             - move to the bottom")
    stdscr.addstr(13, 0, "  [digits]g     - move to trace entry with index [digits]")
    stdscr.addstr(14, 0, "  s             - add trace entry to jump list (markers)")
    stdscr.addstr(15, 0, "  j             - jump to next marker")
    stdscr.addstr(16, 0, "  J             - jump to previous marker")
    stdscr.addstr(17, 0, "  b             - toggle blink / no blink info pane")
    stdscr.addstr(18, 0, "  p             - toggle show probes (only valid for probed src tree)")
    stdscr.addstr(19, 0, "  ENTER         - open current source file in editor")
    stdscr.addstr(20, 0, "  ESCAPE        - exit command mode")
    stdscr.addstr(22, 0, "  Commands")
    stdscr.addstr(23, 0, "  ---------------------------------------------------------")
    stdscr.addstr(24, 0, "  filter core A,B,C-F             - filter on core number")
    stdscr.addstr(25, 0, "  filter core clear               - clear core filter")
    stdscr.addstr(26, 0, "  filter file <regexp>@line       - filter on file@line (@line is optional)")
    stdscr.addstr(27, 0, "  filter file clear               - clear file filter")
    stdscr.addstr(28, 0, "  filter func <regexp>            - filter on function name")
    stdscr.addstr(29, 0, "  filter func clear               - clear func filter")
    stdscr.addstr(30, 0, "  filter src <regexp>             - filter on src line")
    stdscr.addstr(31, 0, "  filter src clear                - clear src filter")
    stdscr.addstr(32, 0, "  filter clear                    - clear all filters")
    stdscr.addstr(34, 0, "  Hints")
    stdscr.addstr(35, 0, "  ---------------------------------------------------------------------")
    stdscr.addstr(36, 0, "  - In command mode, any string prepended by '/' will be searched for)")
    stdscr.addstr(37, 0, "  - When searching, regular expressions can be used by prepending a ' sign")
    stdscr.addstr(38, 0, "    Example: :/'.*foo.*bar")
    stdscr.addstr(39, 0, "  - To search for a trace entry where a variable contains a certain value:")
    stdscr.addstr(40, 0, "    Example: /foo:0x0042")

    c = stdscr.getch()

def launch_editor(stdscr):
    global tracebuffer
    global index
    global relaunch
    global editor

    filename = tracebuffer[index].split("@")[3]
    linenbr = tracebuffer[index].split("@")[4]
    if "vi" in editor or "emacs" in editor or "nano" in editor:
        os.system(editor + " " + linenbr + " " + filename)
    else:
        os.system(editor + " " + filename)
    relaunch = True

def jump(direction):
    global jumplist
    global jumpindex
    global tracebuffer
    global cmd_error_code
    global index

    if len(jumplist) > 0:
        if direction == "forward":
            jumpindex += 1
            if jumpindex >= len(jumplist):
                jumpindex = 0
        else:
            jumpindex -= 1
            if jumpindex < 0:
                jumpindex = len(jumplist) - 1

        # Replace linear search with interval halving later if needed...

        i = 0
        ejump = jumplist[jumpindex]
        found = False
        while i < len(tracebuffer):
            if tracebuffer[i].split("@")[0] == ejump:
                index = i
                found  = True
                break
            i += 1
        if not found:
            cmd_error_code = "Trace entry '" + ejump + "' not available in this filter view"
        else:
            cmd_error_code = "Jumped to marker " + str(jumpindex)
    else:
        cmd_error_code = "No markers set!"

def set_marker():
    global jumpindex
    global jumplist

    curindex = tracebuffer[index].split("@")[0]
    # unset?
    if curindex in jumplist:
        jumplist.remove(curindex)
        return

    jumpindex = len(jumplist)
    jumplist.append(curindex)

def clear_jumplist():
    global jumpindex
    global jumplist

    jumpindex = 0
    jumplist = []

def main(stdscr, relaunched = False):
    global cmd_error_code
    global tracebuffer
    global numbuffer
    global cmdbuffer
    global cmdindex
    global cmdhistory
    global cmdhistoryindex
    global index
    global tv_start
    global tv_end
    global user_input_mode
    global search_dir
    global relaunch
    global w_screen
    global h_screen
    global blink
    global show_probes

    curses.curs_set(0)

    relaunch = False

    if not relaunched:
        init()
        init_screen(stdscr)
        index = len(tracebuffer) - 1

    c = ord('z')

    while 1:
        # resize stuff
        if curses.is_term_resized(h_screen, w_screen):
            init_screen(stdscr)
            stdscr.clear()
#            curses.resizeterm(y, x)

        # cmd being written
        if user_input_mode:
            curses.curs_set(1)
            search_dir = "down"
            if c == 27:
                cmdbuffer = []
                cmdindex = 0
                user_input_mode = False
            elif c == curses.KEY_ENTER or c == 10 or c == 13:
                if len(cmdbuffer) > 0:
                    cmdhistory.insert(1,cmdbuffer.copy())
                    cmdhistoryindex = 0
                    execute_command("".join(cmdbuffer), stdscr)
                    cmdbuffer = []
                    cmdindex = 0
                user_input_mode = False
            elif len(cmdbuffer) > 0 and c == curses.KEY_BACKSPACE:
                cmdindex -= 1
                if cmdindex < 0:
                    cmdindex = 0
                    cmdbuffer = []
                else:
                    cmdbuffer.pop(cmdindex)
            elif len(cmdbuffer) > cmdindex and c == curses.KEY_DC:
                cmdbuffer.pop(cmdindex)
            elif c == curses.KEY_HOME:
                cmdindex = 0
            elif c == curses.KEY_END:
                cmdindex = len(cmdbuffer)
            elif c >= 32 and c <= 126:
                cmdbuffer.insert(cmdindex, chr(c))
                cmdindex += 1
            elif c == curses.KEY_RIGHT:
                cmdindex += 1
                if cmdindex > len(cmdbuffer):
                    cmdindex = len(cmdbuffer)
            elif c == curses.KEY_LEFT:
                cmdindex -= 1
                if cmdindex < 0:
                    cmdindex = 0
            elif c == curses.KEY_DOWN:
                cmdhistoryindex -= 1
                if cmdhistoryindex < 0:
                    cmdhistoryindex = len(cmdhistory) - 1
                cmdbuffer = cmdhistory[cmdhistoryindex].copy()
            elif c == curses.KEY_UP:
                cmdhistoryindex += 1
                if cmdhistoryindex > len(cmdhistory) - 1:
                    cmdhistoryindex = 0
                cmdbuffer = cmdhistory[cmdhistoryindex].copy()
        else:
            curses.curs_set(0)
            if c == ord('h'):
                show_help(stdscr)
            elif c == ord(':'):
                cmd_error_code = ""
                user_input_mode = True
            elif c == ord('/'):
                user_input_mode = True
                cmdbuffer = ['/']
                cmdindex = 1
            elif c == ord('g'):
                if len(numbuffer) > 0:
                    ijump = 0
                    dec = 1
                    for n in reversed(numbuffer):
                        ijump += dec * n
                        dec = dec * 10
                    index = ijump
                    if index < 0:
                        index = 0
                    if index > (len(tracebuffer) - 1):
                        index = len(tracebuffer) - 1
                    numbuffer = []
                else:
                    index = 0

                old_srcpath = ""
            elif c == ord('G'):
                index = len(tracebuffer) - 1
            elif c == ord('n'):
                search_dir = "down"
                execute_command(last_search_cmd, stdscr)
                cmdbuffer = []
                user_input_mode = False
            elif c == ord('N'):
                search_dir = "up"
                execute_command(last_search_cmd, stdscr)
                cmdbuffer = []
                user_input_mode = False
            elif c == curses.KEY_UP:
                if index > 0:
                    index -= 1
            elif c == curses.KEY_DOWN:
                if index < len(tracebuffer) - 1:
                    index += 1
            elif c == curses.KEY_PPAGE:
                index -= num_tracelines
                if index < 0:
                    index = 0
            elif c == curses.KEY_NPAGE:
                index += num_tracelines
                if index > (len(tracebuffer) - 1):
                    index = len(tracebuffer) - 1
            elif c == ord('s'):
                set_marker()
            elif c == ord('c'):
                clear_jumplist()
            elif c == ord('j'):
                jump("forward")
            elif c == ord('J'):
                jump("back")
            elif c == ord('b'):
                if blink:
                    blink = False
                else:
                    blink = True
            elif c == ord('p'):
                if show_probes:
                    show_probes = False
                else:
                    show_probes = True
            elif c >= ord('0') and c <= ord('9'):
                numbuffer.append(int(c - ord('0')))
            elif c == curses.KEY_ENTER or c == 10 or c == 13:
                launch_editor(stdscr)
            if c == ord('q') or relaunch:
                break
        if index < tv_start:
            tv_start = index
        if index >= tv_end:
            tv_start = index - num_tracelines

        tv_end = tv_start + num_tracelines

        draw(stdscr)
#        stdscr.addstr(50, 0, "INDEX: " + str(cmdindex) + "   LIST: " + str(cmdbuffer))
        c = stdscr.getch()

os.environ.setdefault('ESCDELAY', '25')
wrapper(main)
while relaunch:
    os.environ.setdefault('ESCDELAY', '25')
    wrapper(main, relaunched = True)


# EOF
