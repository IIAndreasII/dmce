#!/usr/bin/env bash

function dmce_build_test() {
	local out
	local ret
	local test_start

	ove_echo_cyan_error "dmce-launcher -q -r $1"
	out=$("${OVE_BASE_DIR:?}"/dmce/dmce-launcher -q -r "$1")
	ret=$?
	if [ ${ret} -ne 0 ]; then
		if [[ ${out} == *error* ]]; then
			err_string="$(echo "${out}"| grep error: | sed 's,error: ,,g')"
		else
			err_string="dmce-launcher -q -r $1 failed"
		fi
		ove_echo_red_noprefix "${err_string}"
		return 1
	fi

	# still no probes?
	if ! git grep -q DMCE_PROBE; then
		err_string="no probes inserted"
		return 1
	fi

	ove_echo_cyan_error "ove buildme-parallel ${ove_proj}"
	if ! ove buildme-parallel "${ove_proj}" > /dev/null; then
		err_string="ove buildme-parallel ${ove_proj} failed"
		ove_echo_red_noprefix "${err_string}"
		[ -s "${OVE_LAST_COMMAND}" ] && cat "${OVE_LAST_COMMAND}"
		return 1
	fi

	test_start=$(date '+%Y-%m-%d %H:%M:%S')
	ove_echo_cyan_error "ove test ${ove_proj}"
	if ! ove test "${ove_proj}" > /dev/null; then
		err_string="ove test ${ove_proj} failed"
		ove_echo_red_noprefix "${err_string}"
		[ -s "${OVE_LAST_COMMAND}" ] && cat "${OVE_LAST_COMMAND}"
		return 1
	fi
	journalctl -q --since "${test_start}" | \
		grep -o 'DMCE_PROBE.*' | \
		cut -d: -f4- | \
		sort -V -u > "${OVE_TMP:?}/${name}.log"

	"${OVE_BASE_DIR:?}"/dmce/dmce-summary "${OVE_TMP:?}/${name}.log"

	return 0
}

function usage() {
	local projs
	local repos

	repos="${OVE_REPO_LIST//${OVE_BASE_DIR}\//}"
	repos="${repos/dmce/}"
	repos="${repos/  / }"
	projs="${OVE_PROJECT_LIST/dmce/}"
	projs="${projs/  / }"
	echo "usage:"
	echo "  ${name} git proj mode [revs...]"
	echo
	echo "git:"
	echo "  choose one from: ${repos}"
	echo
	echo "proj:"
	echo "  choose one from: ${projs}"
	echo
	echo "mode:"
	echo "  1: delta coverage"
	echo "  2: full coverage"
	echo "  3: delta and full coverage"
	echo
	echo "revs: (optional)"
	echo "  a list of git revision, if not set get revs from 'git -C <git> tag --sort=-version:refname'"

	exit 1
}

function init() {
	local git_full
	local out

	git="$1"
	git_full="${OVE_BASE_DIR:?}/$1"

	# usage and sanity checks
	if [ $# -lt 3 ]; then
		usage
	elif [ ! -d "${git_full}" ]; then
		echo "error: ${git_full} is not a directory"
		usage
	elif [ ! -d "${git_full}"/.git ]; then
		echo "error: ${git_full} does not appear to be a git repo"
		usage
	fi

	ove_proj="$2"
	mode="$3"
	if [[ ! "${mode}" =~ ^[1-3]$ ]]; then
		echo "error: unknown mode"
		usage
		exit 1
	fi
	shift 3

	if ! cd "${git_full}"; then
		echo "error: 'cd ${git_full}' failed, weird!"
		exit 1
	fi

	out=$("${OVE_BASE_DIR:?}"/dmce/dmce-launcher -c)
	if ! grep -q 'DMCE_PROBE_SOURCE=.*dmce-probe-syslog.c' <<<"${out}"; then
		echo "error: DMCE_PROBE_SOURCE must use 'dmce-probe-syslog.c'. Output from 'dmce-launcher -c':"
		printf "%s\n" "$out" | grep --color -E '^|DMCE_PROBE_SOURCE.*'
		exit 1
	fi

	if ! command -v journalctl > /dev/null; then
		echo "error: command 'journalctl' is missing"
		exit 1
	fi

	if [ "${OVE_REVTAB_CHECK:?}" -eq 1 ]; then
		echo "error: revtab-check is ENABLED for this OVE workspace. Disable it by running 'ove revtab-check 0'"
		exit 1
	fi

	if [ $# -eq 0 ]; then
		mapfile -t revs <<<"$(git tag --sort=-version:refname)"
	else
		revs=("$@")
	fi
	nbr_revs=${#revs[@]}

	if [ "${nbr_revs}" -eq 0 ]; then
		echo "error: no revs"
		exit 1
	elif [ "${nbr_revs}" -eq 1 ]; then
		echo "error: provide at least two revisions"
		exit 1
	fi

	# sanity check
	for i in $(seq 0 $((nbr_revs - 1))); do
		if ! git cat-file -e "${revs[i]}" &> /dev/null; then
			echo "error: '${revs[i]}' is not a valid rev"
			exit 1
		fi
	done
	if [ -n "$PS1" ]; then
		echo "WARNING: ${name} will start by doing a HARD reset (=git reset -q --hard) AND clean up (=git clean -dfxq) this git: ${git_full}"
		read -p "continue? (y/N) " -r
		if ! [[ "${REPLY}" =~ ^[Yy]$ ]]; then
			exit 1
		fi
		read -p "are you REALLY sure? (y/N) " -r
		if ! [[ ${REPLY} =~ ^[Yy]$ ]]; then
			exit 1
		fi
	fi

	echo "revs (${nbr_revs}): ${revs[*]}"
}

function summary() {
	if [ -s "${logfile}" ] && grep -q ^iteration "${logfile}"; then
		echo
		echo "${name} summary:"
		echo "$(grep -c ^iteration "${logfile}") iterations in $((SECONDS - init_time)) seconds"
		echo "revs: ${revs[*]}"
		echo "$ grep ^iteration ${logfile} | sed 's,^iteration ,,g' | column -t -s':'"
		while true; do
			if [ "${mode}" -eq 1 ]; then
				echo "#:date:sha:date:head:date:first:dexec:dprobes:dcov:errors"
			elif [ "${mode}" -eq 2 ]; then
				echo "#:date:sha:date:head:date:first:exec:probes:cov:errors"
			elif [ "${mode}" -eq 3 ]; then
				echo "#:date:sha:date:head:date:first:dexec:dprobes:dcov:exec:probes:cov:errors"
			fi
			grep ^iteration "${logfile}" | sed 's,^iteration ,,g'
			break
		done | column -t -s':'
	fi
}

function main() {
	local date_base
	local date_head

	name=$(basename "$0")
	init_time="${SECONDS}"
	init "$@"

	logfile="${OVE_LAST_COMMAND:?}"

	trap summary EXIT

	ove_echo_cyan_error "ove reset-hard ${git}"
	if ! ove reset-hard "${git}"; then
		ove_echo_red_noprefix "error: 'ove reset-hard ${git}' failed"
		exit 1
	fi
	ove_echo_cyan_error "git clean -dfxq"
	if ! git clean -dfxq; then
		ove_echo_red_noprefix "error: 'git clean -dfxq' failed"
		exit 1
	fi
	ove_echo_cyan_error "ove revtab-sync ${git}"
	if ! ove revtab-sync "${git}" > /dev/null; then
		ove_echo_red_noprefix "error: 'ove revtab-sync ${git}' failed"
		[ -s "${OVE_LAST_COMMAND}" ] && cat "${OVE_LAST_COMMAND}"
		exit 1
	fi

	first=$(git --no-pager log --oneline --pretty=%h | tail -1)
	date_first=$(git log --pretty=%ai "${first}" -1 | awk '{print $1}')

	if [ "${mode}" -eq 3 ]; then
		na_string="NA:NA:NA:NA:NA:NA"
	else
		na_string="NA:NA:NA"
	fi

	for i in $(seq 0 $((nbr_revs - 2))); do
		head=${revs[i]}
		base=${revs[i+1]}

		date_head=$(git log --pretty=%ai "${head}" -1)
		date_head=${date_head%% *}
		date_base=$(git log --pretty=%ai "${base}" -1)
		date_base=${date_base%% *}

		prefix="iteration $((i+1)): ${date_head}:${head}:${date_base}:${base}:${date_first}:${first}"
		if [ "${head}" = "${base}" ]; then
			echo "${prefix}:${na_string}:head=base"
			continue
		fi

		# cleanup
		ove_echo_cyan_error "ove reset-hard ${git}"
		ove reset-hard "${git}"
		ove_echo_cyan_error "git clean -dfxq"
		git clean -dfxq

		# checkout head
		ove_echo_cyan_error "git checkout -q ${head}"
		if ! git checkout -q "${head}"; then
			echo "${prefix}:${na_string}:git checkout ${head} failed"
			continue
		fi

		if [ "${mode}" -eq 1 ] || [ "${mode}" -eq 3 ]; then
			if ! run_one "${base}"; then
				echo "${prefix}:${na_string}:${err_string}"
				continue
			fi

			# save results
			delta_exec=${a_exec}
			delta_probes=${a_probes}
			delta_coverage=${a_coverage}
		fi

		if [ "${mode}" -eq 1 ]; then
			echo "---"
			echo "${prefix}:${delta_exec}:${delta_probes}:${delta_coverage}"
			echo "---"
		else
			ove reset-hard "${git}"
			git clean -dfxq
			if ! run_one "${first}"; then
				echo "${prefix}:${na_string}:${err_string}"
				continue
			fi

			echo "---"
			if [ "${mode}" -eq 2 ]; then
				echo "${prefix}:${a_exec}:${a_probes}:${a_coverage}"
			else
				echo "${prefix}:${delta_exec}:${delta_probes}:${delta_coverage}:${a_exec}:${a_probes}:${a_coverage}"
			fi
			echo "---"
		fi
	done
}

function run_one {
	if ! dmce_build_test "$1"; then
		a_coverage=0
		a_probes=0
		a_exec=0
		return 1
	fi

	a_exec=$(grep '^Uniq probes executed:' "${logfile}" | tail -1)
	a_probes=$(grep '^Number of probes:' "${logfile}" | tail -1)
	a_coverage=$(grep '^Test coverage:' "${logfile}" | tail -1)
	a_exec=${a_exec#*: }
	a_probes=${a_probes#*: }
	a_coverage=${a_coverage#*: }
	a_exec=${a_exec//$'\r'/}
	a_probes=${a_probes//$'\r'/}
	a_coverage=${a_coverage//$'\r'/}

	return 0
}

main "$@"
