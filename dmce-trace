#!/usr/bin/python3

# Copyright (c) 2021 Ericsson AB
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import numpy as np
import sys
import argparse
import os
import re
import glob
from colorama import Fore, Back, Style

parser = argparse.ArgumentParser(description='{}'.format(os.path.basename(__file__)))
parser.add_argument('dfile',            type=str,                   help='Raw ipnut file')
parser.add_argument('probefile',        type=str,                   help='mypath/probe-references.log')
parser.add_argument('codetree',         type=str,                   help='path to code tree')
parser.add_argument('--numvars',        type=int,                   help='Max number of variables, default: 10')
parser.add_argument('--sourcewidth',    type=int, default=80,       help='Width of source code lines, default: 80')
parser.add_argument('-A',               type=int, default=0,        help='Number of trailing source code lines, default: 0')
parser.add_argument('-B',               type=int, default=0,        help='Number of leading source code lines, default: 0')
parser.add_argument('-c',               type=str, default="nocores",help='Comma-separated list of cores to display')
parser.add_argument('--showprobes',     action='store_true',        help='Make probes visible')
parser.add_argument('--verbose',        action='store_true',        help='Verbose output')
parser.add_argument('--delimiter',      type=str, default=":",      help='Delimiter. Default: :')
parser.add_argument('--format',         type=str, default="column", help='Output format (column|raw)')
parser.add_argument('--sort',           type=str, default="seq",    help='Sorting scheme (seq|heat|uniq|collapse), default: seq')
parser.add_argument('-t',               action='store_true',        help='Show timestamps')
parser.add_argument('--hl',             action='store_true',        help='Highlight current source code line')

args = parser.parse_args()

trailing=args.A
leading=args.B
showtimestamps = args.t

# Adjust this according to trace entry struct in probe
TRACE_ENTRY_HEADER = 3

if showtimestamps and args.sort != "seq":
    print("dmce-trace: error: -t cannot be combined with --sort, abort")
    sys.exit(1)

if trailing > 0 or leading > 0:
    keep_src_indent = True
else:
    keep_src_indent = False

if not 'nocores' in args.c:
    cores = args.c.split(',')
else:
    cores = None

dfile = args.dfile
ifilename = dfile + ".info"
ifile = open(ifilename)
info_tmp = ifile.readlines()
ifile.close()
info = []
timestamps2nsecs = 0;
timestamp_start = 0;

count = 0
for line in info_tmp:
    if not "#" in line:
        print(line.rstrip())
        info.append(line)
    else:
        fields = line.split(" ")
        if "trace-start-tsc" in line:
            start_tsc = int(fields[2])
            count += 1
        elif "trace-end-tsc" in line:
            end_tsc = int(fields[2])
            count += 1
        elif "trace-start-secs" in line:
            start_secs = int(fields[2])
            count += 1
        elif "trace-end-secs" in line:
            end_secs = int(fields[2])
            count += 1
        elif "trace-start-nsecs" in line:
            start_nsecs = int(fields[2])
            count += 1
        elif "trace-end-nsecs" in line:
            end_nsecs = int(fields[2])
            count += 1

if count >= 6:
    timestamps2nsecs = (end_tsc - start_tsc) / ( 1000000000 * (end_secs - start_secs) + (end_nsecs - start_nsecs))
    print("CPU timestamps to nanoseconds divider (Nominal cpu clock freq): " + str(timestamps2nsecs), file=sys.stderr)

print("- - - - -")

probefile = args.probefile
codetree = args.codetree

if args.numvars is not None:
    entrysize64 = TRACE_ENTRY_HEADER + args.numvars
else:
    print("Checking trace entry size", file=sys.stderr)
    entrysize64 = 42
    for infoline in info:
        if "te size:" in infoline:
            entrysize64 = int(int(re.search("te size: (\d+)", infoline)[1]) / 8)
            args.numvars = entrysize64 - TRACE_ENTRY_HEADER
            break
    if entrysize64 == 42:
        print("dmce trace: Could not find trace entry size in " + ifilename + ", abort" + str(entrysize64), file=sys.stderr)
        sys.exit(1)

print("Raw input file: " + dfile, file=sys.stderr)
print("Probe ref file: " + probefile, file=sys.stderr)
print("Code tree     : " + codetree, file=sys.stderr)

# Read probe refs file
pf = open(probefile)
prefs = pf.readlines()
pf.close()

# Sanity check if original files  - probed state combo
original = False
if "original" in probefile:
    original = True

state_probed = False
if os.path.exists(codetree + "/.dmce_state_probed"):
    state_probed  = True

if state_probed and original:
    print("dmce trace: Detected a probed code tree combined with " + probefile  + "   Please run dmce-launcher -c to clear probes or use probe-references.log instead, abort", file=sys.stderr)
    exit (1)

if not state_probed and not original:
    print("dmce trace: Detected a non-probed code tree combined with probe-references.log. Please probe the tree or use probe-references-original.log instead, abort", file=sys.stderr)
    exit (1)


# Sanity check if files in probe ref file exist in code tree
for ref in prefs:
    # Check if referenced files exist
    if not os.path.exists(codetree + "/" + ref.rstrip().split(':')[1]):
        print("dmce trace: Probe reference file refers to the file " + codetree + "/" + ref.rstrip().split(':')[1] + " but is does not exist, abort", file=sys.stderr)
        exit (1)

# Find longest path-func combo
longestpath=0

for s in prefs:
    s = ":".join(s.split(":")[1:4])
    l = len(s)
    if l > longestpath:
        longestpath = l

print("Reading trace buffer", file=sys.stderr)

# Read data
data = np.fromfile(dfile, dtype=np.uint64)

print("Sorting out ring buffer", file=sys.stderr)

# uint64_t timestamp, uint64_t probenbr, n * uint64_t variable value
# Find first timestamp where a buffer is exhausted
# TODO: Only search in probes field
deadbeefs = np.where(data == int("deadbeef", 16))
if len(deadbeefs[0]) > 0:
    deadbeefs = deadbeefs[0]
    deadbeeftimestamps = []
    for index in deadbeefs:
        ts = data[index - 1]
        deadbeeftimestamps.append(ts)
    deadbeeftimestamps = np.sort(deadbeeftimestamps)
    fulltracelimit = deadbeeftimestamps[0]
else:
    fulltracelimit = None

length = int(len(data) / entrysize64)
if ( (entrysize64 * length) != len(data) ):
    print("error: datafile has wrong alignment, abort", file=sys.stderr)
    sys.exit(1)

data = np.reshape(data, (length, entrysize64))

print("Sort timestamps", file=sys.stderr)

# Sort on timstamps
data = data[data[:, 0].argsort()]

def stripProbe(s):
    substr = '\(DMCE_PROBE\(\d*'
    for i in range(0, args.numvars):
        substr = substr + '\,[^\,]*'

    substr = substr + '\), '
    s = re.sub(substr, '', s)
    # last paren
    m = re.search('.*(\(.*\))*(\))',s)
    if m:
        s = s[:m.start(2)] + s[m.end(2):]
    return s

def getSourceAndVars(sl, vs, varnames):

    richvs = args.delimiter

    i = 0
    for v in varnames:
        richvs = richvs + v + ":0x" + vs[i] + " "
        i += 1

    return sl, richvs.strip()

def stripProbeExtractVars(sl, vs):
    regexp = r'(.*)\(DMCE_PROBE\(\d*'

    for i in range (0, args.numvars):
        regexp = regexp + '\,(?:\(uint64_t\))*([^\,]*)'

    regexp = regexp + "\)\, (.*)"
    richvs = args.delimiter

    slm = re.match(regexp, sl)
    if slm:
        sl = slm.group(1) + slm.group(args.numvars + 2)

        # last paren
        m = re.search('.*(\(.*\))*(\))', sl)
        if m:
            sl = sl[:m.start(2)] + sl[m.end(2):]

        for i in range (0, args.numvars):
            if slm.group(i + 2) != '0':
                richvs = richvs + slm.group(i + 2) + ":0x" + vs[i] + " "
    return sl, richvs

def notComplete(timestamp):

    if fulltracelimit is None:
        return False
    if fulltracelimit >= timestamp:
        return False
    else:
        return True

# Cache dir tree and source code
tree = glob.glob(codetree + "/**", recursive = True)
treedict = {}
re_source = re.compile('\.c$|\.cpp$|\.cc$|\.h$|\.hh$')
probedtree = False

for filename in tree:
    if os.path.isfile(filename) and re_source.search(filename):
        f = open(filename)
        treedict[filename] = f.readlines()
        f.close()
        if probedtree == False:
            for s in treedict[filename]:
                if "DMCE_PROBE" in s:
                    probedtree = True

outbuf = []

print("Generating trace output", file=sys.stderr)

steps = int(length / 10)

for n in range(length):

    if args.verbose:
        if n % steps == 0:
            print(str(n) + " (" + str(length) + ") " + str(int((n*100) / length)) + "%", file=sys.stderr)

    pnum = data[n, 1]
    cpu = data[n, entrysize64 - 1]

    if cores is not None and str(cpu) not in cores:
        continue

    if pnum != 3735928559 and data[n, 0] != 0:                         # not 0xdeadbeef, timestamp exist
        # Convert to nsecs?
        if timestamps2nsecs:
            data[n, 0] = int((data[n, 0] - start_tsc) / timestamps2nsecs) + start_secs * 1000000000 + start_nsecs

        vs = []
        for v in range(0, args.numvars):
            vs.append(format(data[n,v + 2],"04x"))

        refs = prefs[pnum].rstrip().split(':')
        fname = refs[1]
        line = int(refs[2])
        func = refs[3]
        varnames = refs[4:]
        # Editor line numbers start with 1
        line = line - 1

        # Retrieve source code from cache
        lsource = treedict[codetree + "/" + fname]

        # reset fname
        if args.sort == "heat" or args.sort == "collapse" or args.sort == "uniq":
            fname = ""
        else:
            fname = str(cpu)

        if showtimestamps:
            fname += args.delimiter + str(data[n, 0])

        fname += args.delimiter + codetree + "/" + refs[1]

        if notComplete(data[n, 0]):
            fname += "<Trace incomplete>"

        if leading or trailing:
            print("                                             ---")
        for lcount in range (line - leading, line + 1 + trailing):
            if lcount > 0:
                if 0 <= lcount < len(lsource):
                    if keep_src_indent:
                        sl = lsource[lcount].rstrip()
                    else:
                        sl = lsource[lcount].strip()
                else:
                    continue

                if lcount == line:
                    if not args.showprobes:
                        sl, vs = getSourceAndVars(sl, vs, varnames)
                    else:
                        if not probedtree:
                            print("error: option --noprobes used with unprobed tree, abort", file=sys.stderr)
                            sys.exit(1)
                        sldummy, vs = stripProbeExtractVars(sl, vs)
                    if args.sort == "heat":
                        out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, sl, ""]
                    else:
                        if not args.hl:
                            out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, sl, vs]
                        else:
                            out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, Back.BLUE + sl + Style.RESET_ALL, vs]
                else:
                    if probedtree and not args.showprobes:
                        sl = stripProbe(sl)
                    out = ["", sl, ""]

                if (args.format == "column"):
                    fwidth = longestpath
                    if showtimestamps:
                        fwidth += 22
                    fmt = "{: <"+ str(fwidth + 2) + "} {: <"+ str(args.sourcewidth + 2) + "} {}"
                elif (args.format == "raw"):
                    fmt = "{} {} {}"
                else:
                    print("error: unknown format", file=sys.stderr)
                    sys.exit(1)

                outstr = fmt.format(*out)

                if args.sort != "seq":
                    outbuf.append(outstr)
                else:
                    print(outstr)


def lstr(slist):
    return len(max(slist, key=len))


if args.sort != "seq":
    if args.sort == "uniq":
        sortedarr = np.unique(outbuf, return_counts=True)
        lmax = lstr(sortedarr[0])
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in range(len(sortedarr[0])):
            out = [sortedarr[0][i] , " occurs:" + str(sortedarr[1][i])]
            print( fmt.format(*out) )

    elif args.sort == "heat":
        arr, count = np.unique(outbuf, return_counts=True)
        sind = np.argsort(-count)
        lmax = lstr(arr)
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in sind:
            out = [arr[i] , " heat:" + str(count[i]) ]
            print( fmt.format(*out) )

    elif args.sort == "collapse":
        uniqarr, count = np.unique(outbuf, return_counts=True)
        arr_nodata = []
        for i in range(len(uniqarr)):
            s = uniqarr[i].split(args.delimiter)
            s = args.delimiter.join(s[:5])
            arr_nodata.append(s)

        uniqarr, count = np.unique(arr_nodata, return_counts=True)
        lmax = lstr(uniqarr)
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in range(len(uniqarr)):
            out = [uniqarr[i] , " collapsed:" + str(count[i])]
            print( fmt.format(*out) )


# end of file
