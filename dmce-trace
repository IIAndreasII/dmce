#!/usr/bin/python3

import numpy as np
import sys
import argparse
import os
import re
from colorama import Fore, Back, Style

parser = argparse.ArgumentParser(description='{}'.format(os.path.basename(__file__)))
parser.add_argument('dfile',            type=str,                   help='Raw ipnut file')
parser.add_argument('probefile',        type=str,                   help='mypath/probe-references.log')
parser.add_argument('codetree',         type=str,                   help='path to code tree')
parser.add_argument('--numvars',        type=int, default=0,        help='Number of variables, default: 0')
parser.add_argument('--sourcewidth',    type=int, default=140,       help='Width of source code lines, default: 80')
parser.add_argument('-A',               type=int, default=0,        help='Number of trailing source code lines, default: 0')
parser.add_argument('-B',               type=int, default=0,        help='Number of leading source code lines, default: 0')
parser.add_argument('--showprobes',     action='store_true',        help='Make probes visible')
parser.add_argument('--hl',             action='store_true',        help='Highlight current source code line')
args = parser.parse_args()

trailing=args.A
leading=args.B

#dfile = "/tmp/dmcebuffer.bin"
#probefile = "/tmp/epatabe/dmce/bbx/probe-references.log"
#codetree = "/home/epatabe/repos/bbx"
dfile = args.dfile
probefile = args.probefile
codetree = args.codetree
entrysize64 = 2 + args.numvars

print("Raw input file: " + dfile)
print("Probe ref file: " + probefile)
print("Code tree     : " + codetree)

# Read probe refs file
pf = open(probefile)
prefs = pf.readlines()
pf.close()

data = np.fromfile(dfile, dtype=np.int64)

length = int(len(data) / entrysize64)
if ( (entrysize64 * length) != len(data) ):
    print("Datafile has wrong alignment, abort")
    sys.exit(0)

data = np.reshape(data, (length, entrysize64))

# Sort on timstamps
np.sort(data, 0)

longestpath=0

def stripProbe(s):
    s = re.sub('\(DMCE_PROBE\(\d*\)\, (.*)', r'\1', s)
    s = re.sub('(.*\(.*\))*\)(.*)', r'\1\2', s)
    return s


for n in range(length):
    pnum = data[n, 1]
    vs = ""
    for v in range(0, args.numvars):
        vs = vs + format(data[n,v + 2],"04x") + " "

    refs = prefs[pnum].rstrip().split(':')
    fname = refs[1]
    line = int(refs[2])
    func = refs[3]

    # Editor line numbers start with 1
    line = line - 1
    if len(fname) > longestpath:
        longestpath=len(fname) + len(str(line)) + len(func)

# TODO: When traces grow bigger, read code tree once in the beginning
    fsource = open(codetree + "/" + fname)
    lsource = fsource.readlines()

    if leading or trailing:
        print("                                             ---")
    for lcount in range (line - leading, line + 1 + trailing):
        if lcount > 0:
            sl = lsource[lcount].rstrip()
            if not args.showprobes:
                sl = stripProbe(sl)

            if lcount == line:
                if not args.hl:
                    out = [fname + ":" + str(lcount) + ":" + func, sl, vs]
                else:
                    out = [fname + ":" + str(lcount) + ":" + func, Back.BLUE + sl + Style.RESET_ALL, vs]
            else:
                out = ["", sl, ""]

            fmt = "{: <"+ str(longestpath + 2) + "} {: <"+ str(args.sourcewidth + 2) + "} {}"
            print(fmt.format(*out))

# end of file
