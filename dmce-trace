#!/usr/bin/python3

import numpy as np
import sys
import argparse
import os
import re
import glob
from colorama import Fore, Back, Style

parser = argparse.ArgumentParser(description='{}'.format(os.path.basename(__file__)))
parser.add_argument('dfile',            type=str,                   help='Raw ipnut file')
parser.add_argument('probefile',        type=str,                   help='mypath/probe-references.log')
parser.add_argument('codetree',         type=str,                   help='path to code tree')
parser.add_argument('--numvars',        type=int, default=5,        help='Number of variables, default: 5')
parser.add_argument('--sourcewidth',    type=int, default=80,      help='Width of source code lines, default: 80')
parser.add_argument('-A',               type=int, default=0,        help='Number of trailing source code lines, default: 0')
parser.add_argument('-B',               type=int, default=0,        help='Number of leading source code lines, default: 0')
parser.add_argument('-c',               type=str, default="nocores",help='Comma-separated list of cores to display')
parser.add_argument('--showprobes',     action='store_true',        help='Make probes visible')
parser.add_argument('--verbose',        action='store_true',        help='Verbose output')
parser.add_argument('--delimiter',      type=str, default=":",      help='Delimiter. Default: :')
parser.add_argument('--format',         type=str, default="column", help='Output format (column|raw)')
parser.add_argument('--sort',           type=str, default="seq",    help='Sorting scheme (seq|heat|uniq|collapse), default: seq')
parser.add_argument('-t',               action='store_true',        help='Show timestamps')
parser.add_argument('--hl',             action='store_true',        help='Highlight current source code line')

args = parser.parse_args()

trailing=args.A
leading=args.B
showtimestamps = args.t

if showtimestamps and args.sort != "seq":
    print("dmce-trace: error: -t cannot be combined with --sort, abort")
    sys.exit(1)

if trailing > 0 or leading > 0:
    keep_src_indent = True
else:
    keep_src_indent = False

if not 'nocores' in args.c:
    cores = args.c.split(',')
else:
    cores = None

dfile = args.dfile
probefile = args.probefile
codetree = args.codetree
entrysize64 = 2 + args.numvars + 1

print("Raw input file: " + dfile, file=sys.stderr)
print("Probe ref file: " + probefile, file=sys.stderr)
print("Code tree     : " + codetree, file=sys.stderr)

# Read probe refs file
pf = open(probefile)
prefs = pf.readlines()
pf.close()

# Find longest path-func combo
longestpath=0

for s in prefs:
    s = ":".join(s.split(":")[1:4])
    l = len(s)
    if l > longestpath:
        longestpath = l

print("Reading trace buffer", file=sys.stderr)

# Read data
data = np.fromfile(dfile, dtype=np.int64)

print("Sorting out ring buffer", file=sys.stderr)

# uint64_t timestamp, uint64_t probenbr, n * uint64_t variable value
# Find first timestamp where a buffer is exhausted
# TODO: Only search in probes field
deadbeefs = np.where(data == int("deadbeef", 16))
if len(deadbeefs[0]) > 0:
    deadbeefs = deadbeefs[0]
    deadbeeftimestamps = []
    for index in deadbeefs:
        ts = data[index - 1]
        deadbeeftimestamps.append(ts)
    deadbeeftimestamps = np.sort(deadbeeftimestamps)
    fulltracelimit = deadbeeftimestamps[0]
else:
    fulltracelimit = None

length = int(len(data) / entrysize64)
if ( (entrysize64 * length) != len(data) ):
    print("error: datafile has wrong alignment, abort", file=sys.stderr)
    sys.exit(1)

data = np.reshape(data, (length, entrysize64))

print("Sort timestamps", file=sys.stderr)

# Sort on timstamps
data = data[data[:, 0].argsort()]

def stripProbe(s):
    substr = '\(DMCE_PROBE\(\d*'
    for i in range(0, args.numvars):
        substr = substr + '\,[^\,]*'

    substr = substr + '\), '
    s = re.sub(substr, '', s)
    # last paren
    m = re.search('.*(\(.*\))*(\))',s)
    if m:
        s = s[:m.start(2)] + s[m.end(2):]
    return s

def getSourceAndVars(sl, vs, varnames):

    richvs = args.delimiter

    i = 0
    for v in varnames:
        richvs = richvs + v + ":0x" + vs[i] + " "
        i += 1

    return sl, richvs.strip()

def stripProbeExtractVars(sl, vs):
    regexp = r'(.*)\(DMCE_PROBE\(\d*'

    for i in range (0, args.numvars):
        regexp = regexp + '\,(?:\(uint64_t\))*([^\,]*)'

    regexp = regexp + "\)\, (.*)"
    richvs = args.delimiter

    slm = re.match(regexp, sl)
    if slm:
        sl = slm.group(1) + slm.group(args.numvars + 2)

        # last paren
        m = re.search('.*(\(.*\))*(\))', sl)
        if m:
            sl = sl[:m.start(2)] + sl[m.end(2):]

        for i in range (0, args.numvars):
            if slm.group(i + 2) != '0':
                richvs = richvs + slm.group(i + 2) + ":0x" + vs[i] + " "
    return sl, richvs

def notComplete(timestamp):

    if fulltracelimit is None:
        return False
    if fulltracelimit >= timestamp:
        return False
    else:
        return True

# Cache dir tree and source code
tree = glob.glob(codetree + "/**", recursive = True)
treedict = {}
re_source = re.compile('\.c$|\.cpp$|\.cc$|\.h$|\.hh$')
probedtree = False

for filename in tree:
    if os.path.isfile(filename) and re_source.search(filename):
        f = open(filename)
        treedict[filename] = f.readlines()
        f.close()
        if probedtree == False:
            for s in treedict[filename]:
                if "DMCE_PROBE" in s:
                    probedtree = True

outbuf = []

print("Generating trace output", file=sys.stderr)

steps = int(length / 100)

for n in range(length):

    if args.verbose:
        if n % steps == 0:
            print(str(n) + " (" + str(length) + ") " + str(int((n*100) / length)) + "%", file=sys.stderr)

    pnum = data[n, 1]
    cpu = data[n, entrysize64 - 1]

    if cores is not None and str(cpu) not in cores:
        continue

    if pnum != 3735928559 and data[n, 0] != 0:                         # not 0xdeadbeef, timestamp exist
        vs = []
        for v in range(0, args.numvars):
            vs.append(format(data[n,v + 2],"04x"))

        refs = prefs[pnum].rstrip().split(':')
        fname = refs[1]
        line = int(refs[2])
        func = refs[3]
        varnames = refs[4:]
        # Editor line numbers start with 1
        line = line - 1

        # Retrieve source code from cache
        lsource = treedict[codetree + "/" + fname]

        # reset fname
        fname = str(cpu)

        if showtimestamps:
            fname += args.delimiter + str(data[n, 0])

        fname += args.delimiter + codetree + "/" + refs[1]

        if notComplete(data[n, 0]):
            fname += "<Trace incomplete>"

        if leading or trailing:
            print("                                             ---")
        for lcount in range (line - leading, line + 1 + trailing):
            if lcount > 0:
                if 0 <= lcount < len(lsource):
                    if keep_src_indent:
                        sl = lsource[lcount].rstrip()
                    else:
                        sl = lsource[lcount].strip()
                else:
                    continue

                if lcount == line:
                    if not args.showprobes:
                        if not probedtree:
                            sl, vs = getSourceAndVars(sl, vs, varnames)
                        else:
                            sl, vs = stripProbeExtractVars(sl, vs)
                    else:
                        if not probedtree:
                            print("error: option --noprobes used with unprobed tree, abort", file=sys.stderr)
                            sys.exit(1)
                        sldummy, vs = stripProbeExtractVars(sl, vs)
                    if args.sort == "heat":
                        out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, sl, ""]
                    else:
                        if not args.hl:
                            out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, sl, vs]
                        else:
                            out = [fname + args.delimiter + "+" + str(lcount+1) + args.delimiter + func + args.delimiter, Back.BLUE + sl + Style.RESET_ALL, vs]
                else:
                    if probedtree and not args.showprobes:
                        sl = stripProbe(sl)
                    out = ["", sl, ""]

                if (args.format == "column"):
                    fwidth = longestpath
                    if showtimestamps:
                        fwidth += 22
                    fmt = "{: <"+ str(fwidth + 2) + "} {: <"+ str(args.sourcewidth + 2) + "} {}"
                elif (args.format == "raw"):
                    fmt = "{} {} {}"
                else:
                    print("error: unknown format", file=sys.stderr)
                    sys.exit(1)

                outstr = fmt.format(*out)

                if args.sort != "seq":
                    outbuf.append(outstr)
                else:
                    print(outstr)


def lstr(slist):
    return len(max(slist, key=len))


if args.sort != "seq":
    if args.sort == "uniq":
        sortedarr = np.unique(outbuf, return_counts=True)
        lmax = lstr(sortedarr[0])
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in range(len(sortedarr[0])):
            out = [sortedarr[0][i] , " occurs:" + str(sortedarr[1][i])]
            print( fmt.format(*out) )

    elif args.sort == "heat":
        arr, count = np.unique(outbuf, return_counts=True)
        sind = np.argsort(-count)
        lmax = lstr(arr)
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in sind:
            out = [arr[i] , " heat:" + str(count[i]) ]
            print( fmt.format(*out) )

    elif args.sort == "collapse":
        uniqarr, count = np.unique(outbuf, return_counts=True)
        arr_nodata = []
        for i in range(len(uniqarr)):
            s = uniqarr[i].split(args.delimiter)
            s = args.delimiter.join(s[:5])
            arr_nodata.append(s)

        uniqarr, count = np.unique(arr_nodata, return_counts=True)
        lmax = lstr(uniqarr)
        if args.format == "column":
            fmt = "{: <" + str(lmax) + "} {}"
        else:
            fmt = "{} {}"

        for i in range(len(uniqarr)):
            out = [uniqarr[i] , " collapsed:" + str(count[i])]
            print( fmt.format(*out) )


# end of file
