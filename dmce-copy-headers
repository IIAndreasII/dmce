#!/usr/bin/python3

import sys
import argparse
import os
import shutil
import re
from threading import Thread

descr = 'Copies header files in #include statements from src/... to a path relative to dest'

parser = argparse.ArgumentParser(description=descr)
parser.add_argument('dirsource',    type=str,    help='Source dir')
parser.add_argument('dirdest',    type=str,    help='Destination dir')
args = parser.parse_args()

# Sanity

if not os.path.exists(args.dirsource):
    print("dmce-copy-headers: Error, source directory does not exist: " + args.dirsource)
    sys.exit(1)

if not os.path.exists(args.dirdest):
    print("dmce-copy-headers: Error, destination directory does not exist: " + args.dirdest)
    sys.exit(1)

files_to_parse = []
re_files_to_parse   = re.compile(".*(\.h|\.hh|\.hpp|\.c|\.cc|\.cpp)$")
re_includes         = re.compile(".*#include\s*(<|\")((\w|\.|\/|\s)*)((>|\")*)")

includes_array = []
for i in range(100000):
    includes_array.append(None)

def parse_file(f, index):
    includes = []
    fp = open(f)
    code = fp.readlines()
    for line in code:
        m = re_includes.match(line)
        if m:
            includes.append(m.group(2)) # duplicates handled below

    includes_array[index] = includes.copy()

for path, curdir_dummy, files in os.walk(args.dirsource):
    for f in files:
        if re_files_to_parse.match(f):
            files_to_parse.append(os.path.join(path, f))

threads = []

# TODO: spawn thread for each index
for index in range(len(files_to_parse)):
#    parse_file(files_to_parse[index], index)
    t = Thread(target=parse_file, args=(files_to_parse[index],index,))
    threads.append(t)
    t.start()

# TODO: Join threads after which includes_array is ready
for index in range(len(files_to_parse)):
    threads[index].join()

copied = []

for includes in includes_array:
    if includes is not None:
        for include in includes:
            # To be found in tree?
            for fsource in files_to_parse:
                if re.match(".*" + include.strip() + "$", fsource):
                    # Found subpath/file in tree
                    # Already copied?
                    if include not in copied:
                        copied.append(include)

                        # path exist? If not, create it
                        path = os.path.dirname(args.dirdest + "/" + include.strip())
                        f = os.path.basename(args.dirdest + "/" + include.strip())
                        if not os.path.exists(path):
                            os.makedirs(path)

                        # copy file to path
                        shutil.copy(fsource, path)
                        break
